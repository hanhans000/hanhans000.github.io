<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cockroach: Ascension</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #0a0a0a;
            color: #888;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #ui-bar {
            padding: 10px;
            background: #111;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .stat {
            color: #fff;
            margin: 0 15px;
            font-weight: bold;
        }
        
        .stat.danger { color: #ff4444; }
        .stat.safe { color: #44ff44; }
        
        #game-viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: #000;
            min-height: 400px;
            min-width: 600px;
        }
        
        #ascii-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.3;
            pointer-events: none;
            animation: backgroundPulse 3s ease-in-out infinite;
        }
        
        @keyframes backgroundPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.5; }
        }
        
        #game-map {
            position: absolute;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 16px;
            color: #aaa;
            margin: 0;
            padding: 10px;
            top: 0;
            left: 0;
            background: transparent;
            z-index: 10;
        }
        
        .player { 
            color: #00ff00 !important; 
            background: #002200 !important;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        
        .food { color: #ffaa00; font-weight: bold; }
        .food-chunk { color: #ff8800; font-weight: bold; }
        .exit { 
            background: #ff00ff !important; 
            color: #000 !important; 
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff;
        }
        
        .human { color: #fff; font-weight: bold; text-shadow: 0 0 3px #fff; }
        .ant { color: #ff8800; font-weight: bold; }
        .toxic-warning { 
            background: #00ff00 !important; 
            color: #000 !important; 
            animation: flash 0.3s infinite;
        }
        .toxic-cloud { 
            background: #00ff00 !important; 
            color: #000 !important; 
        }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .paw-shadow { 
            background: #440044 !important; 
            color: #fff !important; 
            opacity: 0.7;
        }
        .paw-print { 
            background: #880088 !important; 
            color: #fff !important; 
            font-weight: bold;
        }
        
        .wall { color: #444; }
        
        #status-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid #ff00ff;
            padding: 20px;
            color: #ff00ff;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            display: none;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #333;
            font-size: 10px;
            color: #888;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="ui-bar">
        <div class="stat" id="level-display">LEVEL: 1 - WET MARKET</div>
        <div class="stat" id="grit-display">GRIT: 50</div>
        <div class="stat" id="moves-display">MOVES: 0</div>
    </div>
    
    <div id="game-viewport">
        <canvas id="ascii-background"></canvas>
        <pre id="game-map"></pre>
        <div id="status-message"></div>
        <div id="instructions">
            ARROWS/WASD: Move | SPACE/ENTER: Wait | Reach the Exit (E) to advance
        </div>
    </div>

    <script>
        // ============ GAME STATE ============
        let gameState = {
            level: 1,
            grit: 50,
            moves: 0,
            player: { x: 5, y: 3 },
            map: [],
            mapWidth: 0,
            mapHeight: 0,
            gameOver: false,
            enemies: [],
            toxicSprays: [],
            pawTimer: 0,
            pawTarget: null
        };
        
        // ============ MAP DATA ============
        const MAPS = {
            1: {
                name: "WET MARKET",
                rawMap: `             ||
_____________||_________________________________________________________________________________________________________________________________________________________
________________________________________________________________________________________________________________________________________________________________________
   .---.                     .---.                                                                                                                                     |
  [  $  ]  [FRESH CATCH]    [  $  ]                                                                                                                        [SERVICE ENTRANCE] |
   '---'  +-------------+    '---'                                                                                                                                _____|_____
    ||    |  /\\\`:·.      |     ||        [FISH $15]             [CRAB $28]           [PORK $12]                                                             | STAFF ONLY|
    ||    | /...\\\`:·   |     ||      +--------------+          +--------------+       .---.   .---.   .---.                                                     | ___________ |
    ||    |             |     ||      | ~  ><[[['> ~|          |  [V]    [V]  |      [   [ ] [   [ ] [   [ ]                                                     | | | | | | |
   _||_   | ><> ><> ><> |    _||_     | ~  ><[[['> ~|          |  [@@]   [@@] |       \ , ]   \ . ]   \ ' ]                                                     | | | | | | |
  /____\  +-------------+   /____\    +--------------+          +--------------+       ] [     ] [     ] [                                                     | : : : : : : |
                                                                                      | |     | |     | |                                                     | . . . . . . |
  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\\`-´░░░░░\\\`-´░░░░░\\\`-´░░░░░░░                                                     |             |
  ░░ .===.   ░░                               ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░                                                     |  [CRATES]   |
  ░░ ||||| ~   ░░                               ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ ~~~~~~~ ░░░░░░░░░░░░░░░░░░░░░░                                                     |  [||||||]   |
  ░░ '==='     ░░                               ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░                                                     |__[||||||]___|
                                                                                                                                                                        \\
   [VEGETABLES]                  [DURIANS]           [BANANAS]               [SPICES & DRY GOODS]           [LOCAL GREENS]           [CITRUS MOUNTAIN]                   \\
   vvv   vvv   vvv                ^,^   ^,^           //   \\\\               ^^^      ^^^                   {{{{{{{}}}}}              o  o  o                       \\  [TO KITCHEN]
  [   ] [   ] [   ]              [* *] [* *]        [[     ]]              ^^^^^    ^^^^^                   {{{{{{}}}}                o o  o o                        >
   \\ /   \\ /   \\ /                \\\`~'   \\\`~'        [[[[   ]]]]             ^^^^^^^  ^^^^^^^                   {{{{{{{{}}}}                o  o  o  o                         /
   _Y_   _Y_   _Y_               [$18/KG ]          [$3/BUN ]              [=======][=======]                 [=======]              [==========]                       /
  +---------------+             [DRAGONFRUIT]       [WATERMELONS]          | $5/100g|| $12/kg |                 |$4/BDL |              | $6/BAG  |                      /
  | $2 / KILO !!! |               ,^,   ,^,         /'''\\             +-------++-------+                 +-------+              +----------+                     /
  +---------------+              <, ,> <, ,>        [:::]::                                                                                                    /
                                  \\\`~'   \\\`'         \\___/                                                                                                   /
                                 [$2/EA  ]          [$5/EA  ]                                                                                                   /
____________________________________________________________________________________________________________________________________________________________________/`,
                startPos: { x: 5, y: 3 },
                exitPos: { x: 205, y: 16 },
                walkable: [' ', '.', '~', ',', '`', '"', ':', ';', '-', '_', '|', '[', ']', '{', '}', '/', '\\', 'o', 'x', 'v', 'V', '@', '*', '^', '<', '>', 'Y', '=', '+', '░'],
                walls: ['#'],
                foods: ['$'],
                foodChunks: ['F', 'f'],
                exits: ['E'],
                enemies: [] // Walking humans will be added dynamically
            },
            2: {
                name: "RESTAURANT KITCHEN",
                rawMap: `                          ||
                          ||
+-------------------------||-----------------------------------------------------------------------+
|    [WALK-IN FRIDGE]     ||                        [DRY STORAGE WAREHOUSE]                        |
|    +----------------+   ||   +---------------------------------------------------------------+   |
|    |  ?   ?   ?     |   ||   |                                                               |   |
|    |  |   |   |     |   ||   |                          )_(        _[_]_                         |   |
|    | [S] [S] [S]    |   ||   |                         .'-'.      /_:_\\                          |   |
|    | [S] [S] [S]    |   ||   |   /-\\         /-\\       |:::|      ]_:_[       {:}       {:}      |   |
|    |  U   U   U     |   ||   |  [ R ]       [ F ]      |:::|      |:._|       {S}       {M}      |   |
|    | [|^^|]  [(@)]  |   ||   |   \\_/         \\_/       '-.-'      \\\`-.-'       {_}       {_}      |   |
|    | [====]  [===]  |   ||   |  [====]     [=====]     [===]     [===]     [=====]     [===]   |   |
|    |                |   ||   |===============================================================|   |
|    |      _   ____  |   ||   |                           mmm        mmm          mmm             |   |
|    |     [_] [____] |   ||   |    __          __         -[        ]-[          ]-[             |   |
|    |     [_]  |@@|  |   ||   |   [  ]        [  ]       [   ]      [   ]        [   ]            |   |
|    |     [_]  \\__/  |   ||   |   [__]        [__]       |   |      |   |        |   |            |   |
|    |      _    U    |   ||   |   [  ]        [  ]       |   |      |   |        |   |            |   |
|    | [~@@~]  [<>< ] |   ||   |   [__]        [__]       |___|      |___|        |___|            |   |
|    | [====]  [====] |   ||   |   [____]      [____]      [|X|]      [|/|]      [oooo]        |   |
|    +-------[0]------+   ||   +---------------------------------------------------------------+   |
|    +-----+-----+-----+  ||   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+       |
|    |     |     |     |  ||   |     |     |     |     |     |     |     |     |     |     |       |
|    +-----+-----+-----+  ||   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+       |
|   +---------------------++-------------------------------------------------------------------+   |
|   |  THE HOT LINE [COOKING STATION]                                                          |   |
|   |                                                                                          |   |
|   |   [WOK STATION 1]          [WOK STATION 2]           [STOVE TOP]            [OVENS]      |   |
|   |                                                                                          |   |
|   |       [  ]                     [  ]                   [  ] [  ]             [~~~~~]      |   |
|   |        ][                       ][                     ][   ][              [~~~~~]      |   |
|   |       [__]                     [__]                   [__] [__]             [__o__]      |   |
|   |      /    \\                   /    \\                 /    \\ /    \\            |     |      |   |
|   |     |______|                 |______|               |_____|_____|            |_____|      |   |
|   |     [==FIRE]                 [==FIRE]               [====GAS====]            [HOT!!]      |   |
|   |                                                                                          |   |
|   +------------------------------------------------------------------------------------------+   |
|          [WIDE CHEF'S ALLEY - DANGER ZONE]                                                       |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+               |
|    |     |     |     |     |     |     |     |     |     |     |     |     |     |               |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+               |
|    |     |     |     |     |     |     |     |     |     |     |     |     |     |               |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+               |
|    |     |     |     |     |     |     |     |     |     |     |     |     |     |               |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+               |
|    |     |     |     |     |     |     |     |     |     |     |     |     |     |               |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+               |
|   +-----------------------------------------------------+   +--------------------------------+   |
|   |  PREP STATION [STAINLESS STEEL]                     |   |  DISH PIT & WASHING            |   |
|   |                                                     |   |                                |   |
|   |    ___________       ___________       ___________  |   |    \\______/       [|||||||]    |   |
|   |   |___________}     |___________}     |___________} |   |     [ SINK ]       [PLATES ]    |   |
|   |    [Chopping]        [Plating]         [Saucing]    |   |     [______]       [PLATES ]    |   |
|   |      _||_              [    ]             _||_      |   |        |                         |   |
|   |     [ vvv]            [      ]           [ @@@]     |   |        | [ ~~~ ~~~ ~~~ ]         |   |
|   |     [Veg ]            [Plate]            [Meat]     |   |        |                         |   |
|   +-----------------------------------------------------+   +-------|------------------------+   |
|                                                                     |                            |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+----+-----+-----+-----+-----+    |
|    |     |     |     |     |     |     |     |     |     |     |    |     |     |     |     |    |
|    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+----+-----+-----+-----+-----+    v
|    |     |     |     |     |     |     |     |     |     |     |    |     |     |     |     |  (TO THE PIPE)
+---------------------------------------------------------------------|                            |`,
                startPos: { x: 7, y: 42 },
                exitPos: { x: 70, y: 58 },
                walkable: [' ', '+', '|', '-', ':', '.', '~', '[', ']', '{', '}', '/', '\\', '_', '=', '?', 'S', 'U', '@', '^', 'v', 'o', 'X', 'x', 'm', '.', '\'', ':', ';'],
                walls: ['#'],
                foods: ['$'],
                foodChunks: ['F', 'f'],
                exits: ['E', 'v'],
                enemies: []
            },
            3: {
                name: "THE BEDROOM",
                rawMap: `[FROM KITCHEN]
                          ||
                          ||
      +=================++=================+
      |          THE SEWER PIPE            |
      |   ▓▓▓▓▓▓▓▓▓▓▓▓||▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓▓▓▓▓||▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓▓▓▓▓||▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓     _  _     ▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓    [o][o]--. ▓▓▓▓▓▓▓▓   | <--- THE MOUSE
      |   ▓▓▓▓▓▓▓▓     \\../ [ ] ▓▓▓▓▓▓▓▓   |      [Blocking path]
      |   ▓▓▓▓▓▓▓▓     m\\/m--m'- ▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓▓▓▓▓||▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓▓▓▓▓||▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   |
      |   ▓▓▓▓▓▓▓▓▓▓▓▓vv▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   |
      +=================++=================+
                          ||
                          ||  [Water dripping]
                          ||
                          vv
+-------------------||---------------------------+
|  SMALL BATHROOM    V  [Vent Entry]             |
|                                                   |
|  [ BATHTUB ]       [ THE TOILET ]               |
|  +---------+       ______________               |
|  | |W| /  /|       |            |               |
|  | |W||  | |       | [||]   [P] |               |
|  | |W||__| |       |____________|               |
|  | |W|     |        _ /   \\ _                 |
|  | |W|[Crt]|       [ [     ] ] [Bowl]          |
|  |___|_____|        \\ \\____/ /                 |
|                      \\______/                  |
|   [TILED FLOOR]             ||                  |
|   +-----+-----+           __||__                |
|   |     |     |          |______|               |
|   +-----+-----+                                 |
|   |     |     |          [ BATH MAT ]           |
|   +-----+-----+           MMMMMMMMMMM           |
+-----------------------------    --------------+
                              | [DOOR]|        
                              |       |        
                              |       |        
+----------------------------------+    +-------------------------------------+
|   THE BEDROOM                    |    |                                     |
|                                  |    |     .-----------.                   |
|   [WARDROBE]                     '-------' .-------. |                   |
|  .-----------------.                             | | C:\\>_ | | [WORK DESK]         |
|  |  ___________    |                             | '-------' |                   |
|  | |  |     |  |   |                             | [Kb] [Ms] |                   |
|  | |  |     |  |   |                             |___________|                   |
|  | |  '--.  |  |   |                              /        \\                   |
|  | | [==] '--' |   |                             /_________\\\\                  |
|  | '-----------'   |                                             (WINDOW)      |
|  '-----------------'                                             +-------+     |
|                                                                  |  * * |     |
|   [QUEEN BED]                                                    | * * |     |
|   .---.________                                                  +-------+     |
|  /   /         /|        :::::::::::::::::                      | [===] |     |
| /___/________/ |        ::  PATTERNED  ::                      |       |     |
| |   |  ====  | |        ::    AREA     ::                      |       |     |
| |___|________|/         :::::::::::::::::                      | [===] |     |
|                         :::::::::::::::::                      |       |     |
|                          [SLEEPING CAT]                        |   /_\\ |     |
|                          |W|/,, |  [\\\`\\\\                        |  [O O]|     |
|                       _.|o o |_   ] ]                        +-------+     |
|                       -[[[---[[[--------                                    |
|                                                                             |
+--------------------------------------------------------------------------------+`,
                startPos: { x: 30, y: 15 },
                exitPos: { x: 25, y: 30 }, // On the bed
                walkable: [' ', '.', ':', ';', '-', '|', '+', '/', '\\', '[', ']', '{', '}', '=', '_', 'v', 'V', 'o', 'O', 'x', 'X', 'w', 'W', 'P', 'M', 'm', 'C', 'K', 'b', 's', ',', '\'', '`', '·', '▓', 'N'],
                walls: ['#'],
                foods: ['$'],
                foodChunks: ['F', 'f'],
                exits: ['E'],
                enemies: []
            }
        };
        
        // ============ ASCII BACKGROUND RENDERING ============
        function renderAsciiBackground(levelNum) {
            const canvas = document.getElementById('ascii-background');
            if (!canvas) return;
            
            const levelData = MAPS[levelNum];
            if (!levelData || !levelData.rawMap) return;
            
            const viewport = document.getElementById('game-viewport');
            canvas.width = viewport.clientWidth || 800;
            canvas.height = viewport.clientHeight || 600;
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set font for ASCII art
            ctx.font = '12px "Courier New", monospace';
            ctx.fillStyle = '#333';
            ctx.textBaseline = 'top';
            
            // Calculate scaling to fit ASCII art
            const lines = levelData.rawMap.split('\n');
            const maxLineLength = Math.max(...lines.map(l => l.length));
            const fontSize = Math.min(12, Math.floor(canvas.width / maxLineLength * 0.8));
            ctx.font = `${fontSize}px "Courier New", monospace`;
            
            // Render ASCII art lines
            const lineHeight = fontSize * 1.2;
            const startY = (canvas.height - (lines.length * lineHeight)) / 2;
            
            lines.forEach((line, index) => {
                // Escape and render each character safely
                const safeLine = line.replace(/[<>&"']/g, (char) => {
                    const map = {'<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;'};
                    return map[char] || char;
                });
                
                // Draw character by character to avoid parsing issues
                let x = (canvas.width - (maxLineLength * fontSize * 0.6)) / 2;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    // Draw printable characters including Unicode (for ░, ▓, etc.)
                    if (char && (char.charCodeAt(0) >= 32 || char.charCodeAt(0) > 127)) {
                        try {
                            ctx.fillText(char, x, startY + (index * lineHeight));
                        } catch (e) {
                            // Skip characters that can't be rendered
                            console.warn('Could not render character:', char);
                        }
                    }
                    x += fontSize * 0.6;
                }
            });
        }
        
        // ============ INITIALIZATION ============
        function initGame() {
            try {
                console.log('Initializing game...');
                loadLevel(1);
                console.log('Level loaded, map size:', gameState.mapWidth, 'x', gameState.mapHeight);
                bindControls();
                updateUI();
                renderAsciiBackground(1);
                console.log('Game initialized successfully');
            } catch (e) {
                console.error('Game initialization error:', e);
                const mapEl = document.getElementById('game-map');
                if (mapEl) {
                    mapEl.innerHTML = 'ERROR: ' + e.message + '<br>' + e.stack;
                    mapEl.style.color = '#ff0000';
                }
            }
        }
        
        // Handle window resize to update background
        window.addEventListener('resize', () => {
            if (gameState.level) {
                renderAsciiBackground(gameState.level);
            }
        });
        
        // Start game when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGame);
        } else {
            initGame();
        }
        
        function loadLevel(levelNum) {
            const levelData = MAPS[levelNum];
            if (!levelData) {
                showMessage("GAME COMPLETE! YOU ASCENDED!");
                return;
            }
            
            gameState.level = levelNum;
            gameState.grit = 50;
            gameState.moves = 0;
            gameState.player = { ...levelData.startPos };
            gameState.gameOver = false;
            gameState.enemies = [];
            gameState.toxicSprays = [];
            gameState.pawTimer = 0;
            gameState.pawTarget = null;
            
            // Render ASCII background first
            renderAsciiBackground(levelNum);
            
            // Parse map - create a simplified grid for game logic
            // We'll use the rawMap dimensions but create a clean grid
            const lines = levelData.rawMap.split('\n');
            gameState.mapHeight = lines.length;
            gameState.mapWidth = Math.max(...lines.map(row => row.length), 1);
            
            // Initialize map as empty grid (game logic doesn't need ASCII art)
            gameState.map = [];
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:498',message:'map initialization start',data:{mapWidth:gameState.mapWidth,mapHeight:gameState.mapHeight,walkableCount:levelData.walkable.length,wallsCount:levelData.walls.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
            // #endregion
            for (let y = 0; y < gameState.mapHeight; y++) {
                const row = [];
                for (let x = 0; x < gameState.mapWidth; x++) {
                    // Check if position is walkable based on level data
                    const char = (lines[y] && lines[y][x]) ? lines[y][x] : ' ';
                    const isWalkable = levelData.walkable.includes(char);
                    const isWall = levelData.walls.includes(char);
                    // #region agent log
                    if (x < 5 && y < 5) { // Log first few tiles
                        fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:504',message:'map tile init',data:{x,y,char,charCode:char.charCodeAt(0),isWalkable,isWall},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                    }
                    // #endregion
                    if (levelData.walkable.includes(char)) {
                        row.push(' ');
                    } else if (levelData.walls.includes(char)) {
                        row.push('#');
                    } else {
                        row.push(' ');
                    }
                }
                gameState.map.push(row);
            }
            
            // Initialize level-specific enemies
            if (levelNum === 1) {
                // Add walking humans (stick figures) - they patrol back and forth
                // Position them at different Y positions along the market floor
                const humanPositions = [
                    { x: 50, y: 3, direction: 1, minX: 20, maxX: 120 },
                    { x: 90, y: 3, direction: -1, minX: 20, maxX: 120 },
                    { x: 140, y: 3, direction: 1, minX: 100, maxX: 190 }
                ];
                humanPositions.forEach(pos => {
                    gameState.enemies.push({
                        type: 'human',
                        x: pos.x,
                        y: pos.y,
                        direction: pos.direction,
                        minX: pos.minX,
                        maxX: pos.maxX
                    });
                });
            } else if (levelNum === 2) {
                // Add scout ants
                for (let i = 0; i < 5; i++) {
                    gameState.enemies.push({
                        type: 'ant',
                        x: 30 + i * 10,
                        y: 42 + (i % 3),
                        targetX: 30 + i * 10,
                        targetY: 42 + (i % 3),
                        moving: false
                    });
                }
            }
            
            // Mark exit
            const exit = levelData.exitPos;
            // #region agent log
            const rawMapLines = levelData.rawMap.split('\n');
            const exitRawChar = rawMapLines[exit.y] && rawMapLines[exit.y][exit.x] ? rawMapLines[exit.y][exit.x] : 'UNDEF';
            const exitMapChar = gameState.map[exit.y] && gameState.map[exit.y][exit.x] ? gameState.map[exit.y][exit.x] : 'UNDEF';
            const exitIsWalkable = levelData.walkable.includes(exitRawChar);
            fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:549',message:'exit placement check',data:{exitX:exit.x,exitY:exit.y,exitRawChar,exitMapChar,exitIsWalkable,mapExists:!!(gameState.map[exit.y] && gameState.map[exit.y][exit.x])},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
            // #endregion
            if (gameState.map[exit.y] && gameState.map[exit.y][exit.x]) {
                gameState.map[exit.y][exit.x] = 'E';
            }
            
            // Add some food items
            addFoodItems(levelNum);
            
            render();
        }
        
        function addFoodItems(levelNum) {
            const levelData = MAPS[levelNum];
            const foodCount = 15;
            
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:560',message:'addFoodItems entry',data:{levelNum,foodCount,mapWidth:gameState.mapWidth,mapHeight:gameState.mapHeight},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            
            for (let i = 0; i < foodCount; i++) {
                let attempts = 0;
                while (attempts < 100) {
                    const x = Math.floor(Math.random() * gameState.mapWidth);
                    const y = Math.floor(Math.random() * gameState.mapHeight);
                    
                    // #region agent log
                    const mapChar = gameState.map[y] && gameState.map[y][x] ? gameState.map[y][x] : 'UNDEF';
                    const rawMapLines = levelData.rawMap.split('\n');
                    const rawChar = rawMapLines[y] && rawMapLines[y][x] ? rawMapLines[y][x] : 'UNDEF';
                    const isWalkableInRaw = levelData.walkable.includes(rawChar);
                    const isWalkableInMap = levelData.walkable.includes(mapChar);
                    fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:570',message:'food placement check',data:{x,y,mapChar,rawChar,isWalkableInRaw,isWalkableInMap,walkableCheck:levelData.walkable.includes(gameState.map[y][x])},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                    // #endregion
                    
                    if (gameState.map[y] && gameState.map[y][x] && 
                        levelData.walkable.includes(gameState.map[y][x]) &&
                        !(x === gameState.player.x && y === gameState.player.y)) {
                        
                        gameState.map[y][x] = '$';
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:575',message:'food placed',data:{x,y,placed:true},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                        // #endregion
                        break;
                    }
                    attempts++;
                }
            }
            
            // Add giant food chunks (represented as F)
            if (levelNum === 1 || levelNum === 2) {
                const giantFoodCount = 3;
                for (let i = 0; i < giantFoodCount; i++) {
                    let attempts = 0;
                    while (attempts < 100) {
                        const x = Math.floor(Math.random() * gameState.mapWidth);
                        const y = Math.floor(Math.random() * gameState.mapHeight);
                        
                        if (gameState.map[y] && gameState.map[y][x] && 
                            levelData.walkable.includes(gameState.map[y][x]) &&
                            !(x === gameState.player.x && y === gameState.player.y)) {
                            
                            // Create a small cluster
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (gameState.map[y + dy] && gameState.map[y + dy][x + dx] &&
                                        levelData.walkable.includes(gameState.map[y + dy][x + dx])) {
                                        gameState.map[y + dy][x + dx] = 'F';
                                    }
                                }
                            }
                            break;
                        }
                        attempts++;
                    }
                }
            }
        }
        
        // ============ CONTROLS ============
        function bindControls() {
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver) return;
                
                let dx = 0, dy = 0;
                
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') dy = -1;
                else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') dy = 1;
                else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') dx = -1;
                else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') dx = 1;
                else if (e.key === ' ' || e.key === 'Enter') {
                    // Wait
                    endTurn();
                    return;
                } else {
                    return;
                }
                
                e.preventDefault();
                movePlayer(dx, dy);
            });
        }
        
        // ============ GAME LOGIC ============
        function movePlayer(dx, dy) {
            const levelData = MAPS[gameState.level];
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:636',message:'movePlayer entry',data:{playerX:gameState.player.x,playerY:gameState.player.y,dx,dy,newX,newY},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
            // #endregion
            
            // Check bounds
            if (newX < 0 || newX >= gameState.mapWidth || newY < 0 || newY >= gameState.mapHeight) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:642',message:'movePlayer out of bounds',data:{newX,newY,mapWidth:gameState.mapWidth,mapHeight:gameState.mapHeight},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                // #endregion
                return;
            }
            
            const tile = gameState.map[newY][newX];
            
            // #region agent log
            const rawMapLines = levelData.rawMap.split('\n');
            const rawChar = rawMapLines[newY] && rawMapLines[newY][newX] ? rawMapLines[newY][newX] : 'UNDEF';
            const isWalkableInRaw = levelData.walkable.includes(rawChar);
            const isWalkableInMap = levelData.walkable.includes(tile);
            fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:646',message:'movePlayer walkability check',data:{newX,newY,tile,rawChar,isWalkableInRaw,isWalkableInMap,isSpecialTile:tile === '$' || tile === 'F' || tile === 'E'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
            // #endregion
            
            // Check if walkable
            if (!levelData.walkable.includes(tile) && tile !== '$' && tile !== 'F' && tile !== 'E') {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:649',message:'movePlayer blocked',data:{newX,newY,tile},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                // #endregion
                return;
            }
            
            // Check collisions with enemies
            if (checkEnemyCollision(newX, newY)) {
                return;
            }
            
            // Move player
            gameState.player.x = newX;
            gameState.player.y = newY;
            gameState.moves++;
            
            // Handle tile interactions
            if (tile === '$') {
                gameState.grit = Math.min(50, gameState.grit + 2);
                gameState.map[newY][newX] = ' ';
                showMessage("ATE CRUMB! +2 GRIT", 500);
            } else if (tile === 'F') {
                gameState.grit = Math.min(50, gameState.grit + 2);
                gameState.map[newY][newX] = ' ';
                showMessage("ATE CHUNK! +2 GRIT", 500);
            } else if (tile === 'E') {
                // Level complete!
                showMessage("LEVEL COMPLETE! ASCENDING...", 1000);
                setTimeout(() => {
                    loadLevel(gameState.level + 1);
                }, 1500);
                return;
            }
            
            // Hunger mechanic: lose 1 Grit every 3 moves
            if (gameState.moves % 3 === 0) {
                gameState.grit--;
                if (gameState.grit <= 0) {
                    gameState.grit = 0;
                    gameOver("STARVED TO DEATH");
                    return;
                }
            }
            
            endTurn();
        }
        
        function checkEnemyCollision(x, y) {
            // Level 1: Walking humans - check all parts (head at y-1, body at y, legs at y+1)
            if (gameState.level === 1) {
                for (let enemy of gameState.enemies) {
                    if (enemy.type === 'human') {
                        // #region agent log
                        const checkY1 = y === enemy.y - 1;
                        const checkY0 = y === enemy.y;
                        const checkY2 = y === enemy.y + 1;
                        const yMinus1Valid = enemy.y - 1 >= 0;
                        const yPlus1Valid = enemy.y + 1 < gameState.mapHeight;
                        fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:700',message:'human collision check',data:{playerX:x,playerY:y,enemyX:enemy.x,enemyY:enemy.y,checkY1,checkY0,checkY2,yMinus1Valid,yPlus1Valid,mapHeight:gameState.mapHeight},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
                        // #endregion
                        // Check if player collides with any part of human (head, body, or legs)
                        if (x === enemy.x && (y === enemy.y - 1 || y === enemy.y || y === enemy.y + 1)) {
                            gameState.grit -= 15;
                            showMessage("TRAMPLED BY HUMAN! -15 GRIT", 800);
                            if (gameState.grit <= 0) {
                                gameOver("CRUSHED");
                                return true;
                            }
                            return true;
                        }
                    }
                }
            }
            
            // Level 2: Ants
            if (gameState.level === 2) {
                for (let enemy of gameState.enemies) {
                    if (enemy.type === 'ant' && enemy.x === x && enemy.y === y) {
                        gameState.grit -= 5;
                        showMessage("ANT BIT! -5 GRIT", 600);
                        if (gameState.grit <= 0) {
                            gameOver("DEFEATED BY ANTS");
                            return true;
                        }
                        return true;
                    }
                }
            }
            
            // Level 2: Toxic spray
            for (let spray of gameState.toxicSprays) {
                if (spray.active && spray.x === x && spray.y === y) {
                    gameState.grit -= 10;
                    showMessage("TOXIC CLOUD! -10 GRIT", 800);
                    if (gameState.grit <= 0) {
                        gameOver("POISONED");
                        return true;
                    }
                    return true;
                }
            }
            
            // Level 3: Cat paw
            if (gameState.level === 3 && gameState.pawTarget) {
                const px = gameState.pawTarget.x;
                const py = gameState.pawTarget.y;
                // 9x4 area
                if (x >= px - 4 && x <= px + 4 && y >= py - 1 && y <= py + 2) {
                    gameState.grit -= 20;
                    showMessage("SMASHED BY CAT PAW! -20 GRIT", 1000);
                    if (gameState.grit <= 0) {
                        gameOver("CRUSHED BY CAT");
                        return true;
                    }
                    return true;
                }
            }
            
            return false;
        }
        
        function endTurn() {
            // Update enemies
            updateEnemies();
            
            // Level-specific hazards
            if (gameState.level === 2) {
                updateToxicSpray();
            } else if (gameState.level === 3) {
                updateCatPaw();
            }
            
            render();
            updateUI();
            
            if (gameState.grit <= 0 && !gameState.gameOver) {
                gameOver("STARVED");
            }
        }
        
        function updateEnemies() {
            const levelData = MAPS[gameState.level];
            
            if (gameState.level === 1) {
                // Walking humans patrol back and forth within their bounds
                gameState.enemies.forEach(enemy => {
                    if (enemy.type === 'human') {
                        const newX = enemy.x + enemy.direction;
                        
                        // Check bounds
                        if (newX < enemy.minX || newX > enemy.maxX) {
                            // Reverse direction at bounds
                            enemy.direction *= -1;
                            enemy.x += enemy.direction;
                        } else if (levelData.walkable.includes(gameState.map[enemy.y][newX]) ||
                                   gameState.map[enemy.y][newX] === ' ' ||
                                   gameState.map[enemy.y][newX] === '.') {
                            enemy.x = newX;
                        } else {
                            // Hit obstacle, reverse
                            enemy.direction *= -1;
                            enemy.x += enemy.direction;
                        }
                    }
                });
            } else if (gameState.level === 2) {
                // Scout ants move randomly
                gameState.enemies.forEach(enemy => {
                    if (enemy.type === 'ant' && Math.random() < 0.3) {
                        const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                        const [dx, dy] = dirs[Math.floor(Math.random() * dirs.length)];
                        const newX = enemy.x + dx;
                        const newY = enemy.y + dy;
                        
                        // #region agent log
                        const boundsCheck = newX > 0 && newX < gameState.mapWidth - 1 && newY > 0 && newY < gameState.mapHeight - 1;
                        const mapTile = gameState.map[newY] && gameState.map[newY][newX] ? gameState.map[newY][newX] : 'UNDEF';
                        const walkableCheck = levelData.walkable.includes(mapTile);
                        fetch('http://127.0.0.1:7242/ingest/616fa030-ed2a-40f0-87e6-a60ea5939942',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'game.html:815',message:'ant movement check',data:{enemyX:enemy.x,enemyY:enemy.y,newX,newY,dx,dy,boundsCheck,mapTile,walkableCheck,willMove:boundsCheck && walkableCheck},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
                        // #endregion
                        
                        if (newX > 0 && newX < gameState.mapWidth - 1 &&
                            newY > 0 && newY < gameState.mapHeight - 1 &&
                            levelData.walkable.includes(gameState.map[newY][newX])) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    }
                });
            }
        }
        
        function updateToxicSpray() {
            // Randomly spawn toxic spray warnings
            if (Math.random() < 0.05 && gameState.toxicSprays.length < 3) {
                const x = Math.floor(Math.random() * gameState.mapWidth);
                const y = Math.floor(Math.random() * gameState.mapHeight);
                const levelData = MAPS[gameState.level];
                
                if (levelData.walkable.includes(gameState.map[y][x])) {
                    gameState.toxicSprays.push({
                        x: x,
                        y: y,
                        active: false,
                        warning: true,
                        timer: 2
                    });
                }
            }
            
            // Update existing sprays
            gameState.toxicSprays.forEach((spray, idx) => {
                if (spray.warning) {
                    spray.timer--;
                    if (spray.timer <= 0) {
                        spray.warning = false;
                        spray.active = true;
                        spray.timer = 3; // Cloud lasts 3 turns
                    }
                } else if (spray.active) {
                    spray.timer--;
                    if (spray.timer <= 0) {
                        gameState.toxicSprays.splice(idx, 1);
                    }
                }
            });
        }
        
        function updateCatPaw() {
            // Cat paw warning then smash (9x4 area)
            if (gameState.pawTimer === 0 && Math.random() < 0.03) {
                gameState.pawTimer = 3; // 3 turns warning
                // Target near player
                gameState.pawTarget = {
                    x: Math.max(4, Math.min(gameState.mapWidth - 5, 
                        gameState.player.x + Math.floor(Math.random() * 7) - 3)),
                    y: Math.max(2, Math.min(gameState.mapHeight - 3,
                        gameState.player.y + Math.floor(Math.random() * 5) - 2))
                };
                showMessage("SHADOW DETECTED ABOVE...", 1500);
            } else if (gameState.pawTimer > 0) {
                gameState.pawTimer--;
                if (gameState.pawTimer === 0) {
                    // Paw smashes down - check if player is hit
                    const px = gameState.pawTarget.x;
                    const py = gameState.pawTarget.y;
                    if (gameState.player.x >= px - 4 && gameState.player.x <= px + 4 &&
                        gameState.player.y >= py - 1 && gameState.player.y <= py + 2) {
                        // Player is in the 9x4 area
                        checkEnemyCollision(gameState.player.x, gameState.player.y);
                    }
                    showMessage("PAW SMASH!", 500);
                    setTimeout(() => {
                        gameState.pawTarget = null;
                        render();
                    }, 1000);
                }
            }
        }
        
        function gameOver(reason) {
            gameState.gameOver = true;
            showMessage(`GAME OVER: ${reason}`, 3000);
        }
        
        // ============ RENDERING ============
        function render() {
            const mapEl = document.getElementById('game-map');
            if (!mapEl) {
                console.error('game-map element not found!');
                return;
            }
            
            const viewport = document.getElementById('game-viewport');
            if (!viewport) {
                mapEl.innerHTML = 'ERROR: viewport not found';
                mapEl.style.color = '#ff0000';
                return;
            }
            
            if (!gameState.map || gameState.map.length === 0) {
                mapEl.innerHTML = 'Loading map... (map is empty)';
                mapEl.style.color = '#ffff00';
                console.log('Map is empty!', gameState);
                return;
            }
            
            const levelData = MAPS[gameState.level];
            if (!levelData) {
                mapEl.innerHTML = 'Level data not found';
                return;
            }
            
            let output = '';
            
            // Calculate camera offset (centered on player)
            const tileWidth = 8; // Character width in pixels
            const tileHeight = 16; // Line height
            const vw = viewport.clientWidth || 800;
            const vh = viewport.clientHeight || 600;
            const viewportWidth = Math.min(100, Math.max(60, Math.floor(vw / tileWidth)));
            const viewportHeight = Math.min(40, Math.max(25, Math.floor(vh / tileHeight)));
            
            // Camera follows player - center player in viewport
            let camX = gameState.player.x - Math.floor(viewportWidth / 2);
            let camY = gameState.player.y - Math.floor(viewportHeight / 2);
            
            // Clamp camera to map bounds
            camX = Math.max(0, Math.min(camX, gameState.mapWidth - viewportWidth));
            camY = Math.max(0, Math.min(camY, gameState.mapHeight - viewportHeight));
            
            // Render visible area - simplified game grid on top of ASCII background
            for (let y = camY; y < Math.min(camY + viewportHeight, gameState.mapHeight); y++) {
                let lineOutput = '';
                for (let x = camX; x < Math.min(camX + viewportWidth, gameState.mapWidth); x++) {
                    // Ensure we have a valid character
                    let char = gameState.map[y] && gameState.map[y][x] ? gameState.map[y][x] : ' ';
                    let classes = [];
                    
                    // Check if player is here
                    if (x === gameState.player.x && y === gameState.player.y) {
                        char = '@';
                        classes.push('player');
                    } else {
                        // Check enemies - render based on type
                        let enemyHere = null;
                        
                        // Check for human stick figures (3 lines tall: head at y-1, body at y, legs at y+1)
                        for (let enemy of gameState.enemies) {
                            if (enemy.type === 'human' && enemy.x === x) {
                                const relY = y - enemy.y;
                                if (relY === -1) {
                                    // Head
                                    enemyHere = enemy;
                                    char = 'O';
                                    break;
                                } else if (relY === 0) {
                                    // Body/arms
                                    enemyHere = enemy;
                                    char = '|';
                                    break;
                                } else if (relY === 1) {
                                    // Legs
                                    enemyHere = enemy;
                                    char = 'V';
                                    break;
                                }
                            } else if (enemy.type === 'ant' && enemy.x === x && enemy.y === y) {
                                enemyHere = enemy;
                                char = 'a';
                                break;
                            }
                        }
                        
                        if (enemyHere) {
                            if (enemyHere.type === 'human') {
                                classes.push('human');
                            } else if (enemyHere.type === 'ant') {
                                classes.push('ant');
                            }
                        } else if (char === '$') {
                            classes.push('food');
                        } else if (char === 'F') {
                            classes.push('food-chunk');
                        } else if (char === 'E') {
                            classes.push('exit');
                        } else if (char === '#') {
                            classes.push('wall');
                            char = '#'; // Simple wall representation
                        } else {
                            // Empty space - show as transparent or minimal
                            char = ' ';
                        }
                        
                        // Level 2: Toxic spray
                        if (gameState.level === 2) {
                            for (let spray of gameState.toxicSprays) {
                                if (spray.x === x && spray.y === y) {
                                    if (spray.warning) {
                                        char = '!';
                                        classes.push('toxic-warning');
                                    } else if (spray.active) {
                                        char = '~';
                                        classes.push('toxic-cloud');
                                    }
                                }
                            }
                        }
                        
                        // Level 3: Cat paw (9x4 area centered on target)
                        if (gameState.level === 3 && gameState.pawTarget) {
                            const px = gameState.pawTarget.x;
                            const py = gameState.pawTarget.y;
                            // 9 wide (px-4 to px+4), 4 tall (py-1 to py+2)
                            if (x >= px - 4 && x <= px + 4 && y >= py - 1 && y <= py + 2) {
                                if (gameState.pawTimer > 0) {
                                    // Warning shadow
                                    classes.push('paw-shadow');
                                    if (x === px && (y === py || y === py + 1)) char = 'o';
                                    else char = '.';
                                } else {
                                    // Actual paw print - show oOo pattern in center
                                    classes.push('paw-print');
                                    if (x === px && y === py) char = 'o';
                                    else if (x === px && y === py + 1) char = 'O';
                                    else if (x === px && y === py + 2) char = 'o';
                                    else char = 'X';
                                }
                            }
                        }
                    }
                    
                    // Escape HTML and build span (handle undefined/null)
                    const escapedChar = (char === undefined || char === null) ? ' ' : String(char);
                    if (classes.length > 0) {
                        lineOutput += `<span class="${classes.join(' ')}">${escapedChar}</span>`;
                    } else {
                        lineOutput += escapedChar;
                    }
                }
                output += lineOutput + '\n';
            }
            
            // Set innerHTML
            if (output.trim() === '') {
                console.error('Empty output generated!', {camX, camY, viewportWidth, viewportHeight, mapWidth: gameState.mapWidth, mapHeight: gameState.mapHeight, player: gameState.player});
                mapEl.innerHTML = 'ERROR: Empty map output<br>Map: ' + gameState.mapWidth + 'x' + gameState.mapHeight + '<br>Player: ' + gameState.player.x + ',' + gameState.player.y;
            } else {
                mapEl.innerHTML = output;
                
                // Position map to show player (camera follows player)
                const offsetX = -camX * tileWidth + 10; // Add padding
                const offsetY = -camY * tileHeight + 10;
                mapEl.style.left = offsetX + 'px';
                mapEl.style.top = offsetY + 'px';
                mapEl.style.color = '#aaa'; // Ensure text is visible
            }
        }
        
        function updateUI() {
            document.getElementById('level-display').textContent = 
                `LEVEL: ${gameState.level} - ${MAPS[gameState.level].name}`;
            document.getElementById('grit-display').textContent = `GRIT: ${gameState.grit}`;
            document.getElementById('moves-display').textContent = `MOVES: ${gameState.moves}`;
            
            const gritEl = document.getElementById('grit-display');
            if (gameState.grit < 10) {
                gritEl.className = 'stat danger';
            } else {
                gritEl.className = 'stat safe';
            }
        }
        
        function showMessage(msg, duration = 1000) {
            const msgEl = document.getElementById('status-message');
            msgEl.textContent = msg;
            msgEl.style.display = 'block';
            setTimeout(() => {
                msgEl.style.display = 'none';
            }, duration);
        }
        
        // Game starts when window loads (see initGame function)
    </script>
</body>
</html>
